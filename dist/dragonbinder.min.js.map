{"version":3,"file":"dragonbinder.min.js","sources":["../lib/index.js"],"sourcesContent":["/**\n * This method checks if a key exists in the object provided\n * @throws {Error} Throws an error if the key does not exists\n * @param {String} objectname The name of the object for log reference\n * @param {Object} object The object in which we will search\n * @param {Object} key The key to search for\n * @returns {Void} //\n */\nfunction keyExists(objectname, object, key) {\n  if (!object[key]) {\n    throw new Error(`The ${objectname} \"${key}\" does not exists.`);\n  }\n}\n\n/**\n * This method checks the provided callback is a function\n * @throws {Error} Throws an error if the callback is not a function\n * @param {String} type The type to use for log reference\n * @param {Object} callback The callback to check\n * @returns {Void} //\n */\nfunction isFunction(type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error(`You need to provide a valid function as ${type}.`);\n  }\n}\n\nfunction getStore(store, namespace) {\n  // store = (store.rootStore || store);\n  let key = namespace;\n\n  if (key.indexOf('.') > -1) {\n    let parts = key.split('.');\n    key = parts.pop();\n    let moduleName = parts.join('.');\n    keyExists('module', store.init.modules, moduleName);\n    store = store.init.modules[moduleName];\n  }\n\n  return {\n    store,\n    key\n  };\n}\n\n/**\n * This is the Store entity\n * @param {Object} data The initial options to create the store\n * @param {Object} [data.state] Optional initial state for the store\n * @param {Object} [data.mutations] Optional mutation methods to update the state\n * @param {Object} [data.actions] Optional actions to handle async methods and update the state\n * @param {Object} [data.getters] Optional getters to read from the state\n * @returns {Object} new store object\n */\nfunction Dragonbinder(data = {}) {\n  let { state, getters, modules, rootStore, namespace } = data;\n  delete data.rootStore;\n  delete data.namespace;\n\n  /**\n   * We will create a proxy for the state\n   */\n  this.state = new Proxy(state || {}, {\n\n    /**\n     * Every time we try to access a property from the state we try to deep freeze the property\n     * to prevent direct modifications to the state\n     * @param {Object} state The state object\n     * @param {String} prop The property to read\n     * @returns {Any} The property value\n     */\n    get: (state, prop) => {\n      if ((this.rootStore || this).init.modules[prop]) {\n        return state[prop];\n      }\n      return this.deepFreeze(state[prop]);\n    },\n\n    /**\n     * If the user tries to set directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to set the value\n     * @param {Object} state The state object\n     * @param {String} prop The property to set\n     * @param {Any} value The property value\n     * @returns {Boolean} Always returns true\n     */\n    set: (state, prop, value) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      state[prop] = value;\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('set', prop, value, old);\n      return true;\n    },\n\n    /**\n     * If the user tries to delete directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to delete the property\n     * @param {Object} state The state object\n     * @param {String} prop The property to delete\n     * @returns {Boolean} Always returns true\n     */\n    deleteProperty: (state, prop) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      delete state[prop];\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('delete', prop, old);\n      return true;\n    }\n  });\n\n  /**\n   * We will define a hidden property to store the init data\n   */\n  Object.defineProperty(this, 'init', {\n    value: {\n      /**\n       * This property will store the frozen state of the store\n       */\n      frozen: true,\n\n      /**\n       * This property will store the plugins\n       */\n      plugins: [],\n\n      /**\n       * This property will store the registered modules\n       */\n      modules: {},\n\n      /**\n       * This property will store the event listeners\n       */\n      listeners: {\n        set: [],\n        delete: [],\n        beforecommit: [],\n        commit: [],\n        beforedispatch: [],\n        dispatch: [],\n        getter: [],\n        addlistener: [],\n        removelistener: [],\n        plugin: []\n      },\n\n      /**\n       * Set initial methods for future reference\n       */\n      getters: data.getters || {},\n      mutations: data.mutations || {},\n      actions: data.actions || {}\n    }\n  });\n\n  /**\n   * We create a proxy for the getters\n   */\n  this.getters = new Proxy(getters || {}, {\n\n    /**\n     * When we try to get a property of the getter we will call the orginal\n     * getter method passing the state as first argument and the other getters as second\n     * if we try to get a non existent getter it will fail silently as if\n     * we were trying to get an undefined property\n     * @param {Object} getters The getters object\n     * @param {String} getter The name of the getter to read\n     * @returns {Any} The value of the getter\n     */\n    get: (getters, getter) => {\n      try {\n        let {store, key} = getStore(this, getter);\n\n        if (store instanceof Dragonbinder && store.init.getters[key]) {\n          let value = store.init.getters[key](store.state, store.getters, this.state, this.getters);\n          if (this.namespace) {\n            getter = `${this.namespace}.${getter}`;\n          }\n          (this.rootStore || this).trigger('getter', getter, value);\n          return value;\n        }\n      } catch (error) {\n        return;\n      }\n    }\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the rootStore for future reference\n   */\n  Object.defineProperty(this, 'rootStore', {\n    value: rootStore || null\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the namespace attached\n   */\n  Object.defineProperty(this, 'namespace', {\n    value: namespace || null\n  });\n\n  /**\n   * Finally we attach the initial modules\n   */\n  if (modules) {\n    Object.keys(modules).forEach(namespace => {\n      let n = this.namespace ? `${this.namespace}.${namespace}` : namespace;\n      (this.rootStore || this).registerModule(n, modules[namespace]);\n    });\n  }\n}\n\nDragonbinder.prototype = Dragonbinder.fn = {\n\n  /**\n   * This method checks if the store is in a state able to mutate the state\n   * @throws {Error} Throws an error if the store is frozen\n   * @returns {Void} //\n   */\n  isUnfrozen() {\n    if (this.init.frozen) {\n      throw new Error('You need to commit a mutation to change the state');\n    }\n  },\n\n  /**\n   * This method is used to deep freeze an object\n   * @param {Object} obj The object to freeze\n   * @returns {Object} Object frozen\n   */\n  deepFreeze(obj) {\n    // deep freeze object only if it isn't already frozen\n    if (!Object.isFrozen(obj)) {\n      Object.getOwnPropertyNames(obj).forEach(\n        prop => typeof obj[prop] === 'object' && obj[prop] !== null && this.deepFreeze(obj[prop])\n      );\n      Object.freeze(obj);\n    }\n\n    return obj;\n  },\n\n  /**\n   * This method unfroze the state and process a mutation\n   * @throws This will trhow an error if the mutation does not exists\n   * @param {String} mutation The mutation name to process\n   * @param  {...any} args The arguments to pass to the mutation\n   * @returns {Void} Void\n   */\n  commit(mutation, ...args) {\n    let {store, key} = getStore(this, mutation);\n    keyExists('mutation', store.init.mutations, key);\n\n    store.init.frozen = false;\n    this.trigger('beforecommit', mutation, ...args);\n    store.init.mutations[key](store.state, ...args);\n    this.trigger('commit', mutation, ...args);\n    store.init.frozen = true;\n  },\n\n  /**\n   * This method process an action\n   * @throws This will throw an error if the action does not exists\n   * @param {String} action The action name to process\n   * @param  {...any} args The arguments to pass to the action\n   * @returns {Promise} The action call as a promise\n   */\n  dispatch(action, ...args) {\n    let {store, key} = getStore(this, action);\n    keyExists('action', store.init.actions, key);\n\n    store.init.frozen = false;\n    this.trigger('beforedispatch', action, ...args);\n    return Promise.resolve(store.init.actions[key](store, ...args)).then((result) => {\n      this.trigger('dispatch', action, ...args);\n      return result;\n    });\n  },\n\n  /**\n   * This method triggers an event\n   * @param {String} event The event name to trigger\n   * @param  {...any} args The arguments that will be passed to the listener\n   * @returns {Void} Void\n   */\n  trigger(event, ...args) {\n    this.init.listeners[event].forEach((callback) => callback(this, ...args));\n  },\n\n  /**\n   * This method adds an event listener to the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to add the listener\n   * @param {Function} listener The listener to add\n   * @returns {Function} The function to unsubscribe\n   */\n  on(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    if (this.init.listeners[event].indexOf(listener) === -1) {\n      this.init.listeners[event].push(listener);\n      this.trigger('addlistener', event, listener);\n    }\n\n    return () => this.off(event, listener);\n  },\n\n  /**\n   * This method removes an event listener from the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to remove the listener\n   * @param {Function} listener The listener to remove\n   * @returns {Void} Void\n   */\n  off(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    let index = this.init.listeners[event].indexOf(listener);\n    if (index > -1) {\n      this.init.listeners[event].splice(index, 1);\n      this.trigger('removelistener', event, listener);\n    }\n  },\n\n  /**\n   * This method adds a plugin to the Store\n   * @throws This will throw an error if the plugin is not a function\n   * @param {Function} plugin The plugin to add\n   * @param {...any} options The options passed to the plugin\n   * @returns {Void} Void\n   */\n  use(plugin, ...options) {\n    isFunction('plugin', plugin);\n    if (this.init.plugins.indexOf(plugin) === -1) {\n      plugin(this, ...options);\n      this.init.plugins.push(plugin);\n      this.trigger('plugin', plugin, ...options);\n    }\n  },\n\n  /**\n   * This method adds a module to the store\n   * @param {String} namespace The namespace to attach the module\n   * @param {Object} module The module definition\n   * @returns {Void} Void\n   */\n  registerModule(namespace, module) {\n    let rootStore = this.rootStore || this;\n    let newStore = new Dragonbinder(Object.assign({rootStore, namespace}, module));\n\n    rootStore.init.modules[namespace] = newStore;\n    rootStore.init.frozen = false;\n    rootStore.state[namespace] = newStore.state;\n    rootStore.init.frozen = true;\n  },\n\n  /**\n   * This method removes a module from the store\n   * @param {String} namespace The namespace of the attached module\n   * @returns {Void} Void\n   */\n  unregisterModule(namespace) {\n    let rootStore = this.rootStore || this;\n\n    rootStore.init.frozen = false;\n    delete rootStore.init.modules[namespace];\n    delete rootStore.state[namespace];\n    rootStore.init.frozen = true;\n  }\n};\n\nDragonbinder.fn = Dragonbinder.prototype;\n\nif (typeof exports === 'object') {\n  module.exports = Dragonbinder;\n} else {\n  (typeof window === 'undefined' ? global : window).Dragonbinder = Dragonbinder;\n}\n"],"names":["keyExists","objectname","object","key","Error","isFunction","type","callback","getStore","store","namespace","indexOf","parts","split","pop","moduleName","join","init","modules","Dragonbinder","data","state","getters","rootStore","this","Proxy","get","prop","deepFreeze","set","value","isUnfrozen","old","trigger","deleteProperty","Object","defineProperty","frozen","plugins","listeners","delete","beforecommit","commit","beforedispatch","dispatch","getter","addlistener","removelistener","plugin","mutations","actions","error","keys","forEach","n","registerModule","prototype","fn","[object Object]","obj","isFrozen","getOwnPropertyNames","freeze","mutation","args","action","Promise","resolve","then","result","event","listener","push","off","index","splice","options","module","newStore","assign","exports","window","global"],"mappings":"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"}