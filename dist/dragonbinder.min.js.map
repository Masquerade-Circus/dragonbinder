{"version":3,"file":"dragonbinder.min.js","sources":["../lib/index.js"],"sourcesContent":["\n/**\n * This is the Store entity\n *\n * @constructor\n * @param {Object} data The initial options to create the store\n * @param {Object} [data.state] Optional initial state for the store\n * @param {Object} [data.mutations] Optional mutation methods to update the state\n * @param {Object} [data.actions] Optional actions to handle async methods and update the state\n * @param {Object} [data.getters] Optional getters to read from the state\n * @param {Object} [data.modules] Optional modules to register to this store\n * @returns {Object} new store object\n */\nfunction Dragonbinder(data = {}) {\n  let { state, getters, modules, rootStore, namespace } = data;\n\n  // Initialize the localState for this store\n  let localState = typeof state === 'function' ? state() : state;\n\n  /**\n   * We create a proxy for the state\n   * @type {Object}\n   * @name Dragonbinder.state\n   */\n  this.state = new Proxy(localState || {}, {\n\n    /**\n     * Every time we try to access a property from the state we try to deep freeze the property\n     * to prevent direct modifications to the state\n     *\n     * @type {Object}\n     * @name Dragonbinder.state.get\n     * @param {Object} state The state object\n     * @param {String} prop The property to read\n     * @returns {Any} The property value\n     */\n    get: (state, prop) => {\n      if ((this.rootStore || this).init.modules[prop]) {\n        return state[prop];\n      }\n      return this.deepFreeze(state[prop]);\n    },\n\n    /**\n     * If the user tries to set directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to set the value\n     *\n     * @type {Object}\n     * @name Dragonbinder.state.set\n     * @param {Object} state The state object\n     * @param {String} prop The property to set\n     * @param {Any} value The property value\n     * @returns {Boolean} Always returns true\n     */\n    set: (state, prop, value) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      state[prop] = value;\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('set', prop, value, old);\n      return true;\n    },\n\n    /**\n     * If the user tries to delete directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to delete the property\n     *\n     * @type {Object}\n     * @name Dragonbinder.state.deleteProperty\n     * @param {Object} state The state object\n     * @param {String} prop The property to delete\n     * @returns {Boolean} Always returns true\n     */\n    deleteProperty: (state, prop) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      delete state[prop];\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('delete', prop, old);\n      return true;\n    }\n  });\n\n  /**\n   * We will define a hidden property to store the init data\n   *\n   * @type {Object}\n   * @name Dragonbinder.init\n   */\n  Object.defineProperty(this, 'init', {\n    value: {\n      /**\n       * This property will store the frozen state of the store\n       *\n       * @type {Boolean}\n       * @name Dragonbinder.init.frozen\n       */\n      frozen: true,\n\n      /**\n       * This property will store the plugins\n       * @type {Array}\n       * @name Dragonbinder.init.plugins\n       */\n      plugins: [],\n\n      /**\n       * This property will store the registered modules\n       * @type {Object}\n       * @name Dragonbinder.init.modules\n       */\n      modules: {},\n\n      /**\n       * This will have the initial child module namespace definitions\n       * @type {Array}\n       * @name Dragonbinder.init.childModuleNamespaces\n       */\n      childModuleNamespaces: Object.keys(modules || {}),\n\n      /**\n       * This property will store the event listeners\n       * @type {Object}\n       * @name Dragonbinder.init.listeners\n       * @property {Array} listeners.set This will store the set event listeners\n       * @property {Array} listeners.delete This will store the delete event listeners\n       * @property {Array} listeners.beforecommit This will store the beforecommit event listeners\n       * @property {Array} listeners.commit This will store the commit event listeners\n       * @property {Array} listeners.beforedispatch This will store the beforedispatch event listeners\n       * @property {Array} listeners.dispatch This will store the dispatch event listeners\n       * @property {Array} listeners.getter This will store the getter event listeners\n       * @property {Array} listeners.addlistener This will store the addlistener event listeners\n       * @property {Array} listeners.removelistener This will store the removelistener event listeners\n       * @property {Array} listeners.plugin This will store the plugin event listeners\n       * @property {Array} listeners.registerModule This will store the registerModule event listeners\n       * @property {Array} listeners.unregisterModule This will store the unregisterModule event listeners\n       */\n      listeners: {\n        set: [],\n        delete: [],\n        beforecommit: [],\n        commit: [],\n        beforedispatch: [],\n        dispatch: [],\n        getter: [],\n        addlistener: [],\n        removelistener: [],\n        plugin: [],\n        registerModule: [],\n        unregisterModule: []\n      },\n\n      /**\n       * Set passed getters for future reference\n       * @type {Object}\n       * @name Dragonbinder.init.getters\n       */\n      getters: data.getters || {},\n\n      /**\n       * Set passed mutations for future reference\n       * @type {Object}\n       * @name Dragonbinder.init.mutations\n       */\n      mutations: data.mutations || {},\n      /**\n       * Set passed actions for future reference\n       * @type {Object}\n       * @name Dragonbinder.init.actions\n       */\n      actions: data.actions || {}\n    }\n  });\n\n  /**\n   * We create a proxy for the getters\n   * @type {Object}\n   * @name Dragonbinder.getters\n   */\n  this.getters = new Proxy(getters || {}, {\n\n    /**\n     * When we try to get a property of the getter we will call the original\n     * getter method passing the state as first argument and the other getters as second\n     * if we try to get a non existent getter it will fail silently as if\n     * we were trying to get an undefined property\n     *\n     * @type {Function}\n     * @name Dragonbinder.getters.get\n     * @param {Object} getters The getters object\n     * @param {String} getter The name of the getter to read\n     * @returns {Any} The value of the getter\n     */\n    get: (getters, getter) => {\n      try {\n        let {store, key} = this.getStore(this, getter);\n\n        if (store instanceof Dragonbinder && store.init.getters[key]) {\n          let value = store.init.getters[key](store.state, store.getters, this.state, this.getters);\n          if (this.namespace) {\n            getter = `${this.namespace}.${getter}`;\n          }\n          (this.rootStore || this).trigger('getter', getter, value);\n          return value;\n        }\n      } catch (error) {\n        return;\n      }\n    }\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the rootStore for future reference\n   *\n   * @type {(Dragonbinder|Null)}\n   * @name Dragonbinder.rootStore\n   */\n  Object.defineProperty(this, 'rootStore', {\n    value: rootStore || null,\n    enumerable: true\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the namespace attached\n   *\n   * @type {(String|Null)}\n   * @name Dragonbinder.namespace\n   */\n  Object.defineProperty(this, 'namespace', {\n    value: namespace || null,\n    enumerable: true\n  });\n\n  /**\n   * Finally we attach the initial modules\n   */\n  if (modules) {\n    Object.keys(modules).forEach(namespace => {\n      let n = this.namespace ? `${this.namespace}.${namespace}` : namespace;\n      (this.rootStore || this).registerModule(n, modules[namespace]);\n    });\n  }\n}\n\nDragonbinder.prototype = Dragonbinder.fn = {\n  /**\n * This method checks if a key exists in the object provided\n * @throws {Error} Throws an error if the key does not exists\n * @param {String} objectname The name of the object for log reference\n * @param {Object} object The object in which we will search\n * @param {Object} key The key to search for\n * @returns {Void} //\n */\n  keyExists(objectname, object, key) {\n    if (!object[key]) {\n      throw new Error(`The ${objectname} \"${key}\" does not exists.`);\n    }\n  },\n\n  /**\n * This method checks the provided callback is a function\n * @throws {Error} Throws an error if the callback is not a function\n * @param {String} type The type to use for log reference\n * @param {Object} callback The callback to check\n * @returns {Void} //\n */\n  isFunction(type, callback) {\n    if (typeof callback !== 'function') {\n      throw new Error(`You need to provide a valid function as ${type}.`);\n    }\n  },\n\n  /**\n * Giving a dot based namespace this method will be used to find the module to be called\n * @param {Dragonbinder} store The store instance in which search for the namespaced module\n * @param {String} namespace The namespace to search\n * @returns {Object} {store, key} An object containing the found module as `store` and the final key as `key` property\n */\n  getStore(store, namespace) {\n    let key = namespace;\n\n    if (key.indexOf('.') > -1) {\n      let parts = key.split('.');\n      key = parts.pop();\n      let moduleName = parts.join('.');\n      this.keyExists('module', store.init.modules, moduleName);\n      store = store.init.modules[moduleName];\n    }\n\n    return {\n      store,\n      key\n    };\n  },\n\n  /**\n   * This method checks if the store is in a state able to mutate the state\n   * @throws {Error} Throws an error if the store is frozen\n   * @returns {Void} //\n   */\n  isUnfrozen() {\n    if (this.init.frozen) {\n      throw new Error('You need to commit a mutation to change the state');\n    }\n  },\n\n  /**\n   * This method is used to deep freeze an object\n   * @param {Object} obj The object to freeze\n   * @returns {Object} Object frozen\n   */\n  deepFreeze(obj) {\n    // deep freeze object only if it isn't already frozen\n    if (!Object.isFrozen(obj)) {\n      Object.getOwnPropertyNames(obj).forEach(\n        prop => typeof obj[prop] === 'object' && obj[prop] !== null && this.deepFreeze(obj[prop])\n      );\n      Object.freeze(obj);\n    }\n\n    return obj;\n  },\n\n  /**\n   * This method unfroze the state and process a mutation\n   * @throws This will trhow an error if the mutation does not exists\n   * @param {String} mutation The mutation name to process\n   * @param  {...any} [args] The arguments to pass to the mutation\n   * @returns {Void} Void\n   */\n  commit(mutation, ...args) {\n    let {store, key} = this.getStore(this, mutation);\n    this.keyExists('mutation', store.init.mutations, key);\n\n    store.init.frozen = false;\n    this.trigger('beforecommit', mutation, ...args);\n    store.init.mutations[key](store.state, ...args);\n    this.trigger('commit', mutation, ...args);\n    store.init.frozen = true;\n  },\n\n  /**\n   * This method process an action\n   * @throws This will throw an error if the action does not exists\n   * @param {String} action The action name to process\n   * @param  {...any} [args] The arguments to pass to the action\n   * @returns {Promise} The action call as a promise\n   */\n  dispatch(action, ...args) {\n    let {store, key} = this.getStore(this, action);\n    this.keyExists('action', store.init.actions, key);\n\n    store.init.frozen = false;\n    this.trigger('beforedispatch', action, ...args);\n    return Promise.resolve(store.init.actions[key](store, ...args)).then((result) => {\n      this.trigger('dispatch', action, ...args);\n      return result;\n    });\n  },\n\n  /**\n   * This method triggers an event\n   * @param {String} event The event name to trigger\n   * @param  {...any} [args] The arguments that will be passed to the listener\n   * @returns {Void} Void\n   */\n  trigger(event, ...args) {\n    this.init.listeners[event].forEach((callback) => callback(this, ...args));\n  },\n\n  /**\n   * This method adds an event listener to the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to add the listener\n   * @param {Function} listener The listener to add\n   * @returns {Function} The function to unsubscribe\n   */\n  on(event, listener) {\n    this.isFunction('listener', listener);\n    this.keyExists('event', this.init.listeners, event);\n    if (this.init.listeners[event].indexOf(listener) === -1) {\n      this.init.listeners[event].push(listener);\n      this.trigger('addlistener', event, listener);\n    }\n\n    return () => this.off(event, listener);\n  },\n\n  /**\n   * This method removes an event listener from the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to remove the listener\n   * @param {Function} listener The listener to remove\n   * @returns {Void} Void\n   */\n  off(event, listener) {\n    this.isFunction('listener', listener);\n    this.keyExists('event', this.init.listeners, event);\n    let index = this.init.listeners[event].indexOf(listener);\n    if (index > -1) {\n      this.init.listeners[event].splice(index, 1);\n      this.trigger('removelistener', event, listener);\n    }\n  },\n\n  /**\n   * This method adds a plugin to the Store\n   * @throws This will throw an error if the plugin is not a function\n   * @param {Function} plugin The plugin to add\n   * @param {...any} [options] The options passed to the plugin\n   * @returns {Void} Void\n   */\n  use(plugin, ...options) {\n    this.isFunction('plugin', plugin);\n    if (this.init.plugins.indexOf(plugin) === -1) {\n      plugin(this, ...options);\n      this.init.plugins.push(plugin);\n      this.trigger('plugin', plugin, ...options);\n    }\n  },\n\n  /**\n   * This method adds a module to the store\n   * @param {String} namespace The namespace to attach the module\n   * @param {Object} module The module definition\n   * @returns {Void} Void\n   */\n  registerModule(namespace, module) {\n    let rootStore = this;\n\n    if (rootStore.init.modules[namespace]) {\n      throw new Error(`A module with the namespace \"${namespace}\" is already registered.`);\n    }\n\n    let newStore = new Dragonbinder(Object.assign({rootStore, namespace}, module));\n\n    rootStore.init.frozen = false;\n    rootStore.init.modules[namespace] = newStore;\n    rootStore.state[namespace] = newStore.state;\n    rootStore.init.frozen = true;\n    rootStore.trigger('registerModule', namespace, module, newStore);\n  },\n\n  /**\n   * This method removes a module from the store\n   * @param {String} namespace The namespace of the attached module\n   * @returns {Void} Void\n   */\n  unregisterModule(namespace) {\n    let rootStore = this;\n    let store = rootStore.init.modules[namespace];\n\n    if (store) {\n      store.init.childModuleNamespaces.forEach(n => rootStore.unregisterModule(`${namespace}.${n}`));\n\n      rootStore.init.frozen = false;\n      delete rootStore.init.modules[namespace];\n      delete rootStore.state[namespace];\n      rootStore.init.frozen = true;\n      rootStore.trigger('unregisterModule', namespace, store);\n    }\n  }\n};\n\nDragonbinder.fn = Dragonbinder.prototype;\n\nif (typeof exports === 'object') {\n  module.exports = Dragonbinder;\n} else {\n  (typeof window === 'undefined' ? global : window).Dragonbinder = Dragonbinder;\n}\n"],"names":["Dragonbinder","data","state","getters","modules","rootStore","namespace","localState","this","Proxy","get","prop","init","deepFreeze","set","value","isUnfrozen","old","trigger","deleteProperty","Object","defineProperty","frozen","plugins","childModuleNamespaces","keys","listeners","delete","beforecommit","commit","beforedispatch","dispatch","getter","addlistener","removelistener","plugin","registerModule","unregisterModule","mutations","actions","store","key","getStore","error","enumerable","forEach","n","prototype","fn","[object Object]","objectname","object","Error","type","callback","indexOf","parts","split","pop","moduleName","join","keyExists","obj","isFrozen","getOwnPropertyNames","freeze","mutation","args","action","Promise","resolve","then","result","event","listener","isFunction","push","off","index","splice","options","module","newStore","assign","exports","window","global"],"mappings":"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"}