{"version":3,"file":"dragonbinder.min.js","sources":["../lib/index.js"],"sourcesContent":["/**\n * This method checks if a key exists in the object provided\n * @throws {Error} Throws an error if the key does not exists\n * @param {String} objectname The name of the object for log reference\n * @param {Object} object The object in which we will search\n * @param {Object} key The key to search for\n * @returns {Void} //\n */\nfunction keyExists(objectname, object, key) {\n  if (!object[key]) {\n    throw new Error(`The ${objectname} \"${key}\" does not exists.`);\n  }\n}\n\n/**\n * This method checks the provided callback is a function\n * @throws {Error} Throws an error if the callback is not a function\n * @param {String} type The type to use for log reference\n * @param {Object} callback The callback to check\n * @returns {Void} //\n */\nfunction isFunction(type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error(`You need to provide a valid function as ${type}.`);\n  }\n}\n\n/**\n * Giving a dot based namespace this method will be used to find the module to be called\n * @param {Dragonbinder} store The store instance in which search for the namespaced module\n * @param {String} namespace The namespace to search\n * @returns {Object} {store, key} An object containing the found module as `store` and the final key as `key` property\n */\nfunction getStore(store, namespace) {\n  let key = namespace;\n\n  if (key.indexOf('.') > -1) {\n    let parts = key.split('.');\n    key = parts.pop();\n    let moduleName = parts.join('.');\n    keyExists('module', store.init.modules, moduleName);\n    store = store.init.modules[moduleName];\n  }\n\n  return {\n    store,\n    key\n  };\n}\n\n/**\n * This is the Store entity\n * @param {Object} data The initial options to create the store\n * @param {Object} [data.state] Optional initial state for the store\n * @param {Object} [data.mutations] Optional mutation methods to update the state\n * @param {Object} [data.actions] Optional actions to handle async methods and update the state\n * @param {Object} [data.getters] Optional getters to read from the state\n * @returns {Object} new store object\n */\nfunction Dragonbinder(data = {}) {\n  let { state, getters, modules, rootStore, namespace } = data;\n\n  // Initialize the localState for this store\n  let localState = typeof state === 'function' ? state() : state;\n\n  /**\n   * We will create a proxy for the state\n   */\n  this.state = new Proxy(localState || {}, {\n\n    /**\n     * Every time we try to access a property from the state we try to deep freeze the property\n     * to prevent direct modifications to the state\n     * @param {Object} state The state object\n     * @param {String} prop The property to read\n     * @returns {Any} The property value\n     */\n    get: (state, prop) => {\n      if ((this.rootStore || this).init.modules[prop]) {\n        return state[prop];\n      }\n      return this.deepFreeze(state[prop]);\n    },\n\n    /**\n     * If the user tries to set directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to set the value\n     * @param {Object} state The state object\n     * @param {String} prop The property to set\n     * @param {Any} value The property value\n     * @returns {Boolean} Always returns true\n     */\n    set: (state, prop, value) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      state[prop] = value;\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('set', prop, value, old);\n      return true;\n    },\n\n    /**\n     * If the user tries to delete directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to delete the property\n     * @param {Object} state The state object\n     * @param {String} prop The property to delete\n     * @returns {Boolean} Always returns true\n     */\n    deleteProperty: (state, prop) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      delete state[prop];\n      if (this.namespace) {\n        prop = `${this.namespace}.${prop}`;\n      }\n      (this.rootStore || this).trigger('delete', prop, old);\n      return true;\n    }\n  });\n\n  /**\n   * We will define a hidden property to store the init data\n   */\n  Object.defineProperty(this, 'init', {\n    value: {\n      /**\n       * This property will store the frozen state of the store\n       */\n      frozen: true,\n\n      /**\n       * This property will store the plugins\n       */\n      plugins: [],\n\n      /**\n       * This property will store the registered modules\n       */\n      modules: {},\n\n      /**\n       * This will have the initial child module namespace definitions\n       */\n      childModuleNamespaces: Object.keys(modules || {}),\n\n      /**\n       * This property will store the event listeners\n       */\n      listeners: {\n        set: [],\n        delete: [],\n        beforecommit: [],\n        commit: [],\n        beforedispatch: [],\n        dispatch: [],\n        getter: [],\n        addlistener: [],\n        removelistener: [],\n        plugin: [],\n        registerModule: [],\n        unregisterModule: []\n      },\n\n      /**\n       * Set initial methods for future reference\n       */\n      getters: data.getters || {},\n      mutations: data.mutations || {},\n      actions: data.actions || {}\n    }\n  });\n\n  /**\n   * We create a proxy for the getters\n   */\n  this.getters = new Proxy(getters || {}, {\n\n    /**\n     * When we try to get a property of the getter we will call the orginal\n     * getter method passing the state as first argument and the other getters as second\n     * if we try to get a non existent getter it will fail silently as if\n     * we were trying to get an undefined property\n     * @param {Object} getters The getters object\n     * @param {String} getter The name of the getter to read\n     * @returns {Any} The value of the getter\n     */\n    get: (getters, getter) => {\n      try {\n        let {store, key} = getStore(this, getter);\n\n        if (store instanceof Dragonbinder && store.init.getters[key]) {\n          let value = store.init.getters[key](store.state, store.getters, this.state, this.getters);\n          if (this.namespace) {\n            getter = `${this.namespace}.${getter}`;\n          }\n          (this.rootStore || this).trigger('getter', getter, value);\n          return value;\n        }\n      } catch (error) {\n        return;\n      }\n    }\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the rootStore for future reference\n   */\n  Object.defineProperty(this, 'rootStore', {\n    value: rootStore || null,\n    enumerable: true\n  });\n\n  /**\n   * If this is a store been attached to another store\n   * this will have the namespace attached\n   */\n  Object.defineProperty(this, 'namespace', {\n    value: namespace || null,\n    enumerable: true\n  });\n\n  /**\n   * Finally we attach the initial modules\n   */\n  if (modules) {\n    Object.keys(modules).forEach(namespace => {\n      let n = this.namespace ? `${this.namespace}.${namespace}` : namespace;\n      (this.rootStore || this).registerModule(n, modules[namespace]);\n    });\n  }\n}\n\nDragonbinder.prototype = Dragonbinder.fn = {\n\n  /**\n   * This method checks if the store is in a state able to mutate the state\n   * @throws {Error} Throws an error if the store is frozen\n   * @returns {Void} //\n   */\n  isUnfrozen() {\n    if (this.init.frozen) {\n      throw new Error('You need to commit a mutation to change the state');\n    }\n  },\n\n  /**\n   * This method is used to deep freeze an object\n   * @param {Object} obj The object to freeze\n   * @returns {Object} Object frozen\n   */\n  deepFreeze(obj) {\n    // deep freeze object only if it isn't already frozen\n    if (!Object.isFrozen(obj)) {\n      Object.getOwnPropertyNames(obj).forEach(\n        prop => typeof obj[prop] === 'object' && obj[prop] !== null && this.deepFreeze(obj[prop])\n      );\n      Object.freeze(obj);\n    }\n\n    return obj;\n  },\n\n  /**\n   * This method unfroze the state and process a mutation\n   * @throws This will trhow an error if the mutation does not exists\n   * @param {String} mutation The mutation name to process\n   * @param  {...any} args The arguments to pass to the mutation\n   * @returns {Void} Void\n   */\n  commit(mutation, ...args) {\n    let {store, key} = getStore(this, mutation);\n    keyExists('mutation', store.init.mutations, key);\n\n    store.init.frozen = false;\n    this.trigger('beforecommit', mutation, ...args);\n    store.init.mutations[key](store.state, ...args);\n    this.trigger('commit', mutation, ...args);\n    store.init.frozen = true;\n  },\n\n  /**\n   * This method process an action\n   * @throws This will throw an error if the action does not exists\n   * @param {String} action The action name to process\n   * @param  {...any} args The arguments to pass to the action\n   * @returns {Promise} The action call as a promise\n   */\n  dispatch(action, ...args) {\n    let {store, key} = getStore(this, action);\n    keyExists('action', store.init.actions, key);\n\n    store.init.frozen = false;\n    this.trigger('beforedispatch', action, ...args);\n    return Promise.resolve(store.init.actions[key](store, ...args)).then((result) => {\n      this.trigger('dispatch', action, ...args);\n      return result;\n    });\n  },\n\n  /**\n   * This method triggers an event\n   * @param {String} event The event name to trigger\n   * @param  {...any} args The arguments that will be passed to the listener\n   * @returns {Void} Void\n   */\n  trigger(event, ...args) {\n    this.init.listeners[event].forEach((callback) => callback(this, ...args));\n  },\n\n  /**\n   * This method adds an event listener to the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to add the listener\n   * @param {Function} listener The listener to add\n   * @returns {Function} The function to unsubscribe\n   */\n  on(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    if (this.init.listeners[event].indexOf(listener) === -1) {\n      this.init.listeners[event].push(listener);\n      this.trigger('addlistener', event, listener);\n    }\n\n    return () => this.off(event, listener);\n  },\n\n  /**\n   * This method removes an event listener from the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to remove the listener\n   * @param {Function} listener The listener to remove\n   * @returns {Void} Void\n   */\n  off(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    let index = this.init.listeners[event].indexOf(listener);\n    if (index > -1) {\n      this.init.listeners[event].splice(index, 1);\n      this.trigger('removelistener', event, listener);\n    }\n  },\n\n  /**\n   * This method adds a plugin to the Store\n   * @throws This will throw an error if the plugin is not a function\n   * @param {Function} plugin The plugin to add\n   * @param {...any} options The options passed to the plugin\n   * @returns {Void} Void\n   */\n  use(plugin, ...options) {\n    isFunction('plugin', plugin);\n    if (this.init.plugins.indexOf(plugin) === -1) {\n      plugin(this, ...options);\n      this.init.plugins.push(plugin);\n      this.trigger('plugin', plugin, ...options);\n    }\n  },\n\n  /**\n   * This method adds a module to the store\n   * @param {String} namespace The namespace to attach the module\n   * @param {Object} module The module definition\n   * @returns {Void} Void\n   */\n  registerModule(namespace, module) {\n    let rootStore = this;\n\n    if (rootStore.init.modules[namespace]) {\n      throw new Error(`A module with the namespace \"${namespace}\" is already registered.`);\n    }\n\n    let newStore = new Dragonbinder(Object.assign({rootStore, namespace}, module));\n\n    rootStore.init.frozen = false;\n    rootStore.init.modules[namespace] = newStore;\n    rootStore.state[namespace] = newStore.state;\n    rootStore.init.frozen = true;\n    rootStore.trigger('registerModule', namespace, module, newStore);\n  },\n\n  /**\n   * This method removes a module from the store\n   * @param {String} namespace The namespace of the attached module\n   * @returns {Void} Void\n   */\n  unregisterModule(namespace) {\n    let rootStore = this;\n    let store = rootStore.init.modules[namespace];\n\n    if (store) {\n      store.init.childModuleNamespaces.forEach(n => rootStore.unregisterModule(`${namespace}.${n}`));\n\n      rootStore.init.frozen = false;\n      delete rootStore.init.modules[namespace];\n      delete rootStore.state[namespace];\n      rootStore.init.frozen = true;\n      rootStore.trigger('unregisterModule', namespace, store);\n    }\n  }\n};\n\nDragonbinder.fn = Dragonbinder.prototype;\n\nif (typeof exports === 'object') {\n  module.exports = Dragonbinder;\n} else {\n  (typeof window === 'undefined' ? global : window).Dragonbinder = Dragonbinder;\n}\n"],"names":["keyExists","objectname","object","key","Error","isFunction","type","callback","getStore","store","namespace","indexOf","parts","split","pop","moduleName","join","init","modules","Dragonbinder","data","state","getters","rootStore","localState","this","Proxy","get","prop","deepFreeze","set","value","isUnfrozen","old","trigger","deleteProperty","Object","defineProperty","frozen","plugins","childModuleNamespaces","keys","listeners","delete","beforecommit","commit","beforedispatch","dispatch","getter","addlistener","removelistener","plugin","registerModule","unregisterModule","mutations","actions","error","enumerable","forEach","n","prototype","fn","[object Object]","obj","isFrozen","getOwnPropertyNames","freeze","mutation","args","action","Promise","resolve","then","result","event","listener","push","off","index","splice","options","module","newStore","assign","exports","window","global"],"mappings":"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"}