{"version":3,"file":"dragonbinder.min.js","sources":["../lib/index.js"],"sourcesContent":["/**\n * This method checks if a key exists in the object provided\n * @throws {Error} Throws an error if the key does not exists\n * @param {String} objectname The name of the object for log reference\n * @param {Object} object The object in which we will search\n * @param {Object} key The key to search for\n * @returns {Void} //\n */\nfunction keyExists(objectname, object, key) {\n  if (!object[key]) {\n    throw new Error(`The ${objectname} \"${key}\" does not exists.`);\n  }\n}\n\n/**\n * This method checks the provided callback is a function\n * @throws {Error} Throws an error if the callback is not a function\n * @param {String} type The type to use for log reference\n * @param {Object} callback The callback to check\n * @returns {Void} //\n */\nfunction isFunction(type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error(`You need to provide a valid function as ${type}.`);\n  }\n}\n\n/**\n * This is the Store entity\n * @param {Object} data The initial options to create the store\n * @param {Object} [data.state] Optional initial state for the store\n * @param {Object} [data.mutations] Optional mutation methods to update the state\n * @param {Object} [data.actions] Optional actions to handle async methods and update the state\n * @param {Object} [data.getters] Optional getters to read from the state\n * @returns {Object} new store object\n */\nfunction Dragonbinder(data = {}) {\n  let { state, getters } = data;\n\n  /**\n   * We will create a proxy for the state\n   */\n  this.state = new Proxy(state || {}, {\n\n    /**\n     * Every time we try to access a property from the state we try to deep freeze the property\n     * to prevent direct modifications to the state\n     * @param {Object} state The state object\n     * @param {String} prop The property to read\n     * @returns {Any} The property value\n     */\n    get: (state, prop) => {\n      return this.deepFreeze(state[prop]);\n    },\n\n    /**\n     * If the user tries to set directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to set the value\n     * @param {Object} state The state object\n     * @param {String} prop The property to set\n     * @param {Any} value The property value\n     * @returns {Boolean} Always returns true\n     */\n    set: (state, prop, value) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      state[prop] = value;\n      this.trigger('set', prop, value, old);\n      return true;\n    },\n\n    /**\n     * If the user tries to delete directly it will throw an error, only if we have unfrozen the state via commit\n     * this will proceed to delete the property\n     * @param {Object} state The state object\n     * @param {String} prop The property to delete\n     * @returns {Boolean} Always returns true\n     */\n    deleteProperty: (state, prop) => {\n      this.isUnfrozen();\n      let old = state[prop];\n      delete state[prop];\n      this.trigger('delete', prop, old);\n      return true;\n    }\n  });\n\n  /**\n   * We will define a hidden property to store the init data\n   */\n  Object.defineProperty(this, 'init', {\n    value: Object.assign({\n      /**\n       * This property will store the frozen state of the store\n       */\n      frozen: true,\n\n      /**\n       * This property will store the plugins\n       */\n      plugins: [],\n\n      /**\n       * This property will store the event listeners\n       */\n      listeners: {\n        set: [],\n        delete: [],\n        beforecommit: [],\n        commit: [],\n        beforedispatch: [],\n        dispatch: [],\n        getter: [],\n        addlistener: [],\n        removelistener: [],\n        plugin: []\n      }\n    }, data)\n  });\n\n  /**\n   * We create a proxy for the getters\n   */\n  this.getters = new Proxy(getters || {}, {\n\n    /**\n     * When we try to get a property of the getter we will call the orginal\n     * getter method passing the state as first argument and the other getters as second\n     * if we try to get a non existent getter it will fail silently as if\n     * we were trying to get an undefined property\n     * @param {Object} getters The getters object\n     * @param {String} getter The name of the getter to read\n     * @returns {Any} The value of the getter\n     */\n    get: (getters, getter) => {\n      if (getters[getter]) {\n        let value = getters[getter](this.state, this.getters);\n        this.trigger('getter', getter, value);\n        return value;\n      }\n    }\n  });\n}\n\nDragonbinder.prototype = Dragonbinder.fn = {\n\n  /**\n   * This method checks if the store is in a state able to mutate the state\n   * @throws {Error} Throws an error if the store is frozen\n   * @returns {Void} //\n   */\n  isUnfrozen() {\n    if (this.init.frozen) {\n      throw new Error('You need to commit a mutation to change the state');\n    }\n  },\n\n  /**\n   * This method is used to deep freeze an object\n   * @param {Object} obj The object to freeze\n   * @returns {Object} Object frozen\n   */\n  deepFreeze(obj) {\n    // deep freeze object only if it isn't already frozen\n    if (!Object.isFrozen(obj)) {\n      Object.getOwnPropertyNames(obj).forEach(\n        prop => typeof obj[prop] === 'object' && obj[prop] !== null && this.deepFreeze(obj[prop])\n      );\n      Object.freeze(obj);\n    }\n\n    return obj;\n  },\n\n  /**\n   * This method unfroze the state and process a mutation\n   * @throws This will trhow an error if the mutation does not exists\n   * @param {String} mutation The mutation name to process\n   * @param  {...any} args The arguments to pass to the mutation\n   * @returns {Void} Void\n   */\n  commit(mutation, ...args) {\n    keyExists('mutation', this.init.mutations, mutation);\n    this.init.frozen = false;\n    this.trigger('beforecommit', mutation, ...args);\n    this.init.mutations[mutation](this.state, ...args);\n    this.trigger('commit', mutation, ...args);\n    this.init.frozen = true;\n  },\n\n  /**\n   * This method process an action\n   * @throws This will throw an error if the action does not exists\n   * @param {String} action The action name to process\n   * @param  {...any} args The arguments to pass to the action\n   * @returns {Promise} The action call as a promise\n   */\n  dispatch(action, ...args) {\n    keyExists('action', this.init.actions, action);\n    this.trigger('beforedispatch', action, ...args);\n    return Promise.resolve(this.init.actions[action](this, ...args)).then((result) => {\n      this.trigger('dispatch', action, ...args);\n      return result;\n    });\n  },\n\n  /**\n   * This method triggers an event\n   * @param {String} event The event name to trigger\n   * @param  {...any} args The arguments that will be passed to the listener\n   * @returns {Void} Void\n   */\n  trigger(event, ...args) {\n    this.init.listeners[event].forEach((callback) => callback(this, ...args));\n  },\n\n  /**\n   * This method adds an event listener to the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to add the listener\n   * @param {Function} listener The listener to add\n   * @returns {Function} The function to unsubscribe\n   */\n  on(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    if (this.init.listeners[event].indexOf(listener) === -1) {\n      this.init.listeners[event].push(listener);\n      this.trigger('addlistener', event, listener);\n    }\n\n    return () => this.off(event, listener);\n  },\n\n  /**\n   * This method removes an event listener from the store\n   * @throws This will throw an error if the listener is not a function\n   * @throws This will throw an error if the event does not exists\n   * @param {String} event The event to which to remove the listener\n   * @param {Function} listener The listener to remove\n   * @returns {Void} Void\n   */\n  off(event, listener) {\n    isFunction('listener', listener);\n    keyExists('event', this.init.listeners, event);\n    let index = this.init.listeners[event].indexOf(listener);\n    if (index > -1) {\n      this.init.listeners[event].splice(index, 1);\n      this.trigger('removelistener', event, listener);\n    }\n  },\n\n  /**\n   * This method adds a plugin to the Store\n   * @throws This will throw an error if the plugin is not a function\n   * @param {Function} plugin The plugin to add\n   * @param {...any} options The options passed to the plugin\n   * @returns {Void} Void\n   */\n  use(plugin, ...options) {\n    isFunction('plugin', plugin);\n    if (this.init.plugins.indexOf(plugin) === -1) {\n      plugin(this, ...options);\n      this.init.plugins.push(plugin);\n      this.trigger('plugin', plugin, ...options);\n    }\n  }\n};\n\nDragonbinder.fn = Dragonbinder.prototype;\n\nif (typeof exports === 'object') {\n  module.exports = Dragonbinder;\n} else {\n  (typeof window === 'undefined' ? global : window).Dragonbinder = Dragonbinder;\n}\n"],"names":["keyExists","objectname","object","key","Error","isFunction","type","callback","Dragonbinder","data","state","getters","this","Proxy","get","prop","deepFreeze","set","value","isUnfrozen","old","trigger","deleteProperty","Object","defineProperty","assign","frozen","plugins","listeners","delete","beforecommit","commit","beforedispatch","dispatch","getter","addlistener","removelistener","plugin","prototype","fn","[object Object]","init","obj","isFrozen","getOwnPropertyNames","forEach","freeze","mutation","args","mutations","action","actions","Promise","resolve","then","result","event","listener","indexOf","push","off","index","splice","options","exports","module","window","global"],"mappings":"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"}